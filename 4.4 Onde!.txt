Colocamos a palavra-chave where (geralmente identamos até onde estão os pipes) e definimos variáveis ou funções. Esses nomes são visíveis dentro dos guards e nos permitem não ficar nos repetindo. Se decidirmos que iremos calcular o IMC de um modo diferente, precisamos mudar apenas uma vez. Podemos avançar um pouco e deixar nossa função de IMC assim:

bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | bmi <= skinny = "Você esta abaixo do peso!"  
    | bmi <= normal = "Supostamente você esta normal. Pfff, aposto que você é feio!"  
    | bmi <= fat    = "Você esta gordo! Faça uma dieta, gorducho!"  
    | otherwise     = "Você é uma baleia, meus parabéns!"  
    where bmi = weight / height ^ 2  
          skinny = 18.5  
          normal = 25.0  
          fat = 30.0 

Os nomes criados na seção where só são visíveis dentro da função, então não temos de nos preocupar com elas poluindo o namespace de outras funções. Note também que todos os nomes foram alinhados na mesma coluna. Se não o fizéssemos, Haskell ficaria confuso e não saberia que eles fazem parte do mesmo bloco.

Associações where não são compartilhadas entre diferentes patterns. Se você quiser que vários patterns de uma mesma função compartilhem um determinado nome, você deverá especificá-los como global.

Você também pode usar where em conjunto com pattern match! Poderíamos reescrever a parte where da nossa função anterior como:

...  
where bmi = weight / height ^ 2  
      (skinny, normal, fat) = (18.5, 25.0, 30.0) 
 
Vamos fazer agora outra função extremamente necessária que recebe nome e sobrenome e retorna suas iniciais.

initials :: String -> String -> String  
initials firstname lastname = [f] ++ ". " ++ [l] ++ "."  
    where (f:_) = firstname  
          (l:_) = lastname 

